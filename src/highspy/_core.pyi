from typing import Callable, ClassVar, List, Tuple

from typing import overload
import numpy
HIGHS_VERSION_MAJOR: int
HIGHS_VERSION_MINOR: int
HIGHS_VERSION_PATCH: int
kBasisValidityInvalid: BasisValidity
kBasisValidityValid: BasisValidity
kHighsIInf: int
kHighsInf: float
kSolutionStatusFeasible: SolutionStatus
kSolutionStatusInfeasible: SolutionStatus
kSolutionStatusNone: SolutionStatus

class BasisValidity:
    __doc__: ClassVar[str] = ...  # read-only
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kBasisValidityInvalid: ClassVar[BasisValidity] = ...
    kBasisValidityValid: ClassVar[BasisValidity] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class HessianFormat:
    __doc__: ClassVar[str] = ...  # read-only
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kSquare: ClassVar[HessianFormat] = ...
    kTriangular: ClassVar[HessianFormat] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class HighsBasis:
    alien: bool
    col_status: List[HighsBasisStatus]
    debug_id: int
    debug_origin_name: str
    debug_update_count: int
    row_status: List[HighsBasisStatus]
    valid: bool
    was_alien: bool
    def __init__(self) -> None: ...

class HighsBasisStatus:
    __doc__: ClassVar[str] = ...  # read-only
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kBasic: ClassVar[HighsBasisStatus] = ...
    kLower: ClassVar[HighsBasisStatus] = ...
    kNonbasic: ClassVar[HighsBasisStatus] = ...
    kUpper: ClassVar[HighsBasisStatus] = ...
    kZero: ClassVar[HighsBasisStatus] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class HighsHessian:
    dim_: int
    format_: HessianFormat
    index_: List[int]
    start_: List[int]
    value_: List[float]
    def __init__(self) -> None: ...

class HighsIis:
    col_bound: List[int]
    col_index: List[int]
    info: List[HighsIisInfo]
    row_bound: List[int]
    row_index: List[int]
    strategy: int
    valid: bool
    def __init__(self) -> None: ...
    def invalidate(self) -> None: ...

class HighsIisInfo:
    simplex_iterations: int
    simplex_time: float
    def __init__(self) -> None: ...

class HighsInfo:
    basis_validity: int
    crossover_iteration_count: int
    dual_solution_status: int
    ipm_iteration_count: int
    max_complementarity_violation: float
    max_dual_infeasibility: float
    max_integrality_violation: float
    max_primal_infeasibility: float
    mip_dual_bound: float
    mip_gap: float
    mip_node_count: int
    num_dual_infeasibilities: int
    num_primal_infeasibilities: int
    objective_function_value: float
    pdlp_iteration_count: int
    primal_solution_status: int
    qp_iteration_count: int
    simplex_iteration_count: int
    sum_complementarity_violations: float
    sum_dual_infeasibilities: float
    sum_primal_infeasibilities: float
    valid: bool
    def __init__(self) -> None: ...

class HighsInfoType:
    __doc__: ClassVar[str] = ...  # read-only
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kDouble: ClassVar[HighsInfoType] = ...
    kInt: ClassVar[HighsInfoType] = ...
    kInt64: ClassVar[HighsInfoType] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class HighsLogType:
    __doc__: ClassVar[str] = ...  # read-only
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kDetailed: ClassVar[HighsLogType] = ...
    kError: ClassVar[HighsLogType] = ...
    kInfo: ClassVar[HighsLogType] = ...
    kVerbose: ClassVar[HighsLogType] = ...
    kWarning: ClassVar[HighsLogType] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class HighsLp:
    a_matrix_: HighsSparseMatrix
    col_cost_: List[float]
    col_lower_: List[float]
    col_names_: List[str]
    col_upper_: List[float]
    integrality_: List[HighsVarType]
    is_moved_: bool
    is_scaled_: bool
    model_name_: str
    mods_: HighsLpMods
    num_col_: int
    num_row_: int
    offset_: float
    row_lower_: List[float]
    row_names_: List[str]
    row_upper_: List[float]
    scale_: HighsScale
    sense_: ObjSense
    def __init__(self) -> None: ...

class HighsModel:
    hessian_: HighsHessian
    lp_: HighsLp
    def __init__(self) -> None: ...

class HighsModelStatus:
    __doc__: ClassVar[str] = ...  # read-only
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kInfeasible: ClassVar[HighsModelStatus] = ...
    kInterrupt: ClassVar[HighsModelStatus] = ...
    kIterationLimit: ClassVar[HighsModelStatus] = ...
    kLoadError: ClassVar[HighsModelStatus] = ...
    kMemoryLimit: ClassVar[HighsModelStatus] = ...
    kModelEmpty: ClassVar[HighsModelStatus] = ...
    kModelError: ClassVar[HighsModelStatus] = ...
    kNotset: ClassVar[HighsModelStatus] = ...
    kObjectiveBound: ClassVar[HighsModelStatus] = ...
    kObjectiveTarget: ClassVar[HighsModelStatus] = ...
    kOptimal: ClassVar[HighsModelStatus] = ...
    kPostsolveError: ClassVar[HighsModelStatus] = ...
    kPresolveError: ClassVar[HighsModelStatus] = ...
    kSolutionLimit: ClassVar[HighsModelStatus] = ...
    kSolveError: ClassVar[HighsModelStatus] = ...
    kTimeLimit: ClassVar[HighsModelStatus] = ...
    kUnbounded: ClassVar[HighsModelStatus] = ...
    kUnboundedOrInfeasible: ClassVar[HighsModelStatus] = ...
    kUnknown: ClassVar[HighsModelStatus] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class HighsObjectiveSolution:
    col_value: List[float]
    objective: float
    def __init__(self) -> None: ...

class HighsOptionType:
    __doc__: ClassVar[str] = ...  # read-only
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kBool: ClassVar[HighsOptionType] = ...
    kDouble: ClassVar[HighsOptionType] = ...
    kInt: ClassVar[HighsOptionType] = ...
    kString: ClassVar[HighsOptionType] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class HighsOptions:
    allow_unbounded_or_infeasible: bool
    allowed_matrix_scale_factor: int
    dual_feasibility_tolerance: float
    highs_analysis_level: int
    highs_debug_level: int
    infinite_bound: float
    infinite_cost: float
    ipm_iteration_limit: int
    ipm_optimality_tolerance: float
    ipx_dualize_strategy: int
    large_matrix_value: float
    log_dev_level: int
    log_file: str
    log_to_console: bool
    mip_abs_gap: float
    mip_detect_symmetry: bool
    mip_feasibility_tolerance: float
    mip_heuristic_effort: float
    mip_lp_age_limit: int
    mip_max_improving_sols: int
    mip_max_leaves: int
    mip_max_nodes: int
    mip_max_stall_nodes: int
    mip_min_cliquetable_entries_for_parallelism: int
    mip_min_logging_interval: float
    mip_pool_age_limit: int
    mip_pool_soft_limit: int
    mip_pscost_minreliable: int
    mip_rel_gap: float
    mip_report_level: int
    objective_bound: float
    objective_target: float
    output_flag: bool
    parallel: str
    presolve: str
    primal_feasibility_tolerance: float
    random_seed: int
    ranging: str
    run_crossover: str
    simplex_crash_strategy: int
    simplex_dual_edge_weight_strategy: int
    simplex_dualize_strategy: int
    simplex_iteration_limit: int
    simplex_max_concurrency: int
    simplex_min_concurrency: int
    simplex_permute_strategy: int
    simplex_price_strategy: int
    simplex_primal_edge_weight_strategy: int
    simplex_scale_strategy: int
    simplex_strategy: int
    simplex_update_limit: int
    small_matrix_value: float
    solution_file: str
    solver: str
    threads: int
    time_limit: float
    write_model_file: str
    write_model_to_file: bool
    write_solution_style: int
    write_solution_to_file: bool
    def __init__(self) -> None: ...

class HighsPresolveStatus:
    __doc__: ClassVar[str] = ...  # read-only
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kInfeasible: ClassVar[HighsPresolveStatus] = ...
    kNotPresolved: ClassVar[HighsPresolveStatus] = ...
    kNotReduced: ClassVar[HighsPresolveStatus] = ...
    kNullError: ClassVar[HighsPresolveStatus] = ...
    kOptionsError: ClassVar[HighsPresolveStatus] = ...
    kReduced: ClassVar[HighsPresolveStatus] = ...
    kReducedToEmpty: ClassVar[HighsPresolveStatus] = ...
    kTimeout: ClassVar[HighsPresolveStatus] = ...
    kUnboundedOrInfeasible: ClassVar[HighsPresolveStatus] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class HighsRanging:
    col_bound_dn: HighsRangingRecord
    col_bound_up: HighsRangingRecord
    col_cost_dn: HighsRangingRecord
    col_cost_up: HighsRangingRecord
    row_bound_dn: HighsRangingRecord
    row_bound_up: HighsRangingRecord
    valid: bool
    def __init__(self) -> None: ...

class HighsRangingRecord:
    in_var_: List[int]
    objective_: List[float]
    ou_var_: List[int]
    value_: List[float]
    def __init__(self) -> None: ...

class HighsSolution:
    col_dual: List[float]
    col_value: List[float]
    dual_valid: bool
    row_dual: List[float]
    row_value: List[float]
    value_valid: bool
    def __init__(self) -> None: ...

class HighsSparseMatrix:
    format_: MatrixFormat
    index_: List[int]
    num_col_: int
    num_row_: int
    p_end_: List[int]
    start_: List[int]
    value_: List[float]
    def __init__(self) -> None: ...

class HighsStatus:
    __doc__: ClassVar[str] = ...  # read-only
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kError: ClassVar[HighsStatus] = ...
    kOk: ClassVar[HighsStatus] = ...
    kWarning: ClassVar[HighsStatus] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class HighsVarType:
    __doc__: ClassVar[str] = ...  # read-only
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kContinuous: ClassVar[HighsVarType] = ...
    kInteger: ClassVar[HighsVarType] = ...
    kSemiContinuous: ClassVar[HighsVarType] = ...
    kSemiInteger: ClassVar[HighsVarType] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class IisBoundStatus:
    __doc__: ClassVar[str] = ...  # read-only
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kIisBoundStatusBoxed: ClassVar[IisBoundStatus] = ...
    kIisBoundStatusDropped: ClassVar[IisBoundStatus] = ...
    kIisBoundStatusFree: ClassVar[IisBoundStatus] = ...
    kIisBoundStatusLower: ClassVar[IisBoundStatus] = ...
    kIisBoundStatusNull: ClassVar[IisBoundStatus] = ...
    kIisBoundStatusUpper: ClassVar[IisBoundStatus] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class IisStrategy:
    __doc__: ClassVar[str] = ...  # read-only
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kIisStrategyFromLpColPriority: ClassVar[IisStrategy] = ...
    kIisStrategyFromLpRowPriority: ClassVar[IisStrategy] = ...
    kIisStrategyMax: ClassVar[IisStrategy] = ...
    kIisStrategyMin: ClassVar[IisStrategy] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class MatrixFormat:
    __doc__: ClassVar[str] = ...  # read-only
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kColwise: ClassVar[MatrixFormat] = ...
    kRowwise: ClassVar[MatrixFormat] = ...
    kRowwisePartitioned: ClassVar[MatrixFormat] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ObjSense:
    __doc__: ClassVar[str] = ...  # read-only
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kMaximize: ClassVar[ObjSense] = ...
    kMinimize: ClassVar[ObjSense] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class SolutionStatus:
    __doc__: ClassVar[str] = ...  # read-only
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kSolutionStatusFeasible: ClassVar[SolutionStatus] = ...
    kSolutionStatusInfeasible: ClassVar[SolutionStatus] = ...
    kSolutionStatusNone: ClassVar[SolutionStatus] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class _Highs:
    def __init__(self) -> None: ...
    def addCol(self, arg0: float, arg1: float, arg2: float, arg3: int, arg4: numpy.ndarray[numpy.int32], arg5: numpy.ndarray[numpy.float64]) -> HighsStatus: ...
    def addCols(self, arg0: int, arg1: numpy.ndarray[numpy.float64], arg2: numpy.ndarray[numpy.float64], arg3: numpy.ndarray[numpy.float64], arg4: int, arg5: numpy.ndarray[numpy.int32], arg6: numpy.ndarray[numpy.int32], arg7: numpy.ndarray[numpy.float64]) -> HighsStatus: ...
    def addRow(self, arg0: float, arg1: float, arg2: int, arg3: numpy.ndarray[numpy.int32], arg4: numpy.ndarray[numpy.float64]) -> HighsStatus: ...
    def addRows(self, arg0: int, arg1: numpy.ndarray[numpy.float64], arg2: numpy.ndarray[numpy.float64], arg3: int, arg4: numpy.ndarray[numpy.int32], arg5: numpy.ndarray[numpy.int32], arg6: numpy.ndarray[numpy.float64]) -> HighsStatus: ...
    def addVar(self, arg0: float, arg1: float) -> HighsStatus: ...
    def addVars(self, arg0: int, arg1: numpy.ndarray[numpy.float64], arg2: numpy.ndarray[numpy.float64]) -> HighsStatus: ...
    def basisStatusToString(self, arg0: HighsBasisStatus) -> str: ...
    def basisValidityToString(self, arg0: int) -> str: ...
    def changeCoeff(self, arg0: int, arg1: int, arg2: float) -> HighsStatus: ...
    def changeColBounds(self, arg0: int, arg1: float, arg2: float) -> HighsStatus: ...
    def changeColCost(self, arg0: int, arg1: float) -> HighsStatus: ...
    def changeColIntegrality(self, arg0: int, arg1: HighsVarType) -> HighsStatus: ...
    def changeColsBounds(self, arg0: int, arg1: numpy.ndarray[numpy.int32], arg2: numpy.ndarray[numpy.float64], arg3: numpy.ndarray[numpy.float64]) -> HighsStatus: ...
    def changeColsCost(self, arg0: int, arg1: numpy.ndarray[numpy.int32], arg2: numpy.ndarray[numpy.float64]) -> HighsStatus: ...
    def changeColsIntegrality(self, arg0: int, arg1: numpy.ndarray[numpy.int32], arg2: numpy.ndarray[numpy.uint8]) -> HighsStatus: ...
    def changeObjectiveOffset(self, arg0: float) -> HighsStatus: ...
    def changeObjectiveSense(self, arg0: ObjSense) -> HighsStatus: ...
    def changeRowBounds(self, arg0: int, arg1: float, arg2: float) -> HighsStatus: ...
    def clear(self) -> HighsStatus: ...
    def clearModel(self) -> HighsStatus: ...
    def clearSolver(self) -> HighsStatus: ...
    def crossover(self, arg0: HighsSolution) -> HighsStatus: ...
    def deleteCols(self, arg0: int, arg1: List[int]) -> HighsStatus: ...
    def deleteRows(self, arg0: int, arg1: List[int]) -> HighsStatus: ...
    def deleteVars(self, arg0: int, arg1: List[int]) -> HighsStatus: ...
    def feasibilityRelaxation(self, global_lower_penalty: float, global_upper_penalty: float, global_rhs_penalty: float, local_lower_penalty: object = ..., local_upper_penalty: object = ..., local_rhs_penalty: object = ...) -> HighsStatus: ...
    def getBasis(self) -> HighsBasis: ...
    def getCol(self, arg0: int) -> Tuple[HighsStatus,float,float,float,int]: ...
    def getColByName(self, arg0: str) -> Tuple[HighsStatus,int]: ...
    def getColEntries(self, arg0: int) -> Tuple[HighsStatus,numpy.ndarray[numpy.int32],numpy.ndarray[numpy.float64]]: ...
    def getColName(self, arg0: int) -> Tuple[HighsStatus,str]: ...
    def getCols(self, arg0: int, arg1: numpy.ndarray[numpy.int32]) -> Tuple[HighsStatus,int,numpy.ndarray[numpy.float64],numpy.ndarray[numpy.float64],numpy.ndarray[numpy.float64],int]: ...
    def getColsEntries(self, arg0: int, arg1: numpy.ndarray[numpy.int32]) -> Tuple[HighsStatus,numpy.ndarray[numpy.int32],numpy.ndarray[numpy.int32],numpy.ndarray[numpy.float64]]: ...
    def getHessianNumNz(self) -> int: ...
    def getIis(self, arg0: HighsIis) -> HighsStatus: ...
    def getInfinity(self) -> float: ...
    def getInfo(self) -> HighsInfo: ...
    def getInfoType(self, arg0: str) -> Tuple[HighsStatus,HighsInfoType]: ...
    def getInfoValue(self, arg0: str) -> Tuple[HighsStatus,object]: ...
    def getLp(self) -> HighsLp: ...
    def getModel(self) -> HighsModel: ...
    def getModelPresolveStatus(self) -> HighsPresolveStatus: ...
    def getModelStatus(self) -> HighsModelStatus: ...
    def getNumCol(self) -> int: ...
    def getNumNz(self) -> int: ...
    def getNumRow(self) -> int: ...
    def getObjectiveOffset(self) -> Tuple[HighsStatus,float]: ...
    def getObjectiveSense(self) -> Tuple[HighsStatus,ObjSense]: ...
    def getObjectiveValue(self) -> float: ...
    def getOptionType(self, arg0: str) -> Tuple[HighsStatus,HighsOptionType]: ...
    def getOptionValue(self, arg0: str) -> Tuple[HighsStatus,object]: ...
    def getOptions(self) -> HighsOptions: ...
    def getPresolvedLp(self) -> HighsLp: ...
    def getRanging(self) -> Tuple[HighsStatus,HighsRanging]: ...
    def getRow(self, arg0: int) -> Tuple[HighsStatus,float,float,int]: ...
    def getRowByName(self, arg0: str) -> Tuple[HighsStatus,int]: ...
    def getRowEntries(self, arg0: int) -> Tuple[HighsStatus,numpy.ndarray[numpy.int32],numpy.ndarray[numpy.float64]]: ...
    def getRowName(self, arg0: int) -> Tuple[HighsStatus,str]: ...
    def getRows(self, arg0: int, arg1: numpy.ndarray[numpy.int32]) -> Tuple[HighsStatus,int,numpy.ndarray[numpy.float64],numpy.ndarray[numpy.float64],int]: ...
    def getRowsEntries(self, arg0: int, arg1: numpy.ndarray[numpy.int32]) -> Tuple[HighsStatus,numpy.ndarray[numpy.int32],numpy.ndarray[numpy.int32],numpy.ndarray[numpy.float64]]: ...
    def getRunTime(self) -> float: ...
    def getSavedMipSolutions(self) -> List[HighsObjectiveSolution]: ...
    def getSolution(self) -> HighsSolution: ...
    def githash(self) -> str: ...
    def modelStatusToString(self, arg0: HighsModelStatus) -> str: ...
    def passColName(self, arg0: int, arg1: str) -> HighsStatus: ...
    @overload
    def passHessian(self, arg0: HighsHessian) -> HighsStatus: ...
    @overload
    def passHessian(self, arg0: int, arg1: int, arg2: int, arg3: numpy.ndarray[numpy.int32], arg4: numpy.ndarray[numpy.int32], arg5: numpy.ndarray[numpy.float64]) -> HighsStatus: ...
    @overload
    def passModel(self, arg0: HighsModel) -> HighsStatus: ...
    @overload
    def passModel(self, arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int, arg7: float, arg8: numpy.ndarray[numpy.float64], arg9: numpy.ndarray[numpy.float64], arg10: numpy.ndarray[numpy.float64], arg11: numpy.ndarray[numpy.float64], arg12: numpy.ndarray[numpy.float64], arg13: numpy.ndarray[numpy.int32], arg14: numpy.ndarray[numpy.int32], arg15: numpy.ndarray[numpy.float64], arg16: numpy.ndarray[numpy.int32], arg17: numpy.ndarray[numpy.int32], arg18: numpy.ndarray[numpy.float64], arg19: numpy.ndarray[numpy.int32]) -> HighsStatus: ...
    @overload
    def passModel(self, arg0: HighsLp) -> HighsStatus: ...
    @overload
    def passModel(self, arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: float, arg6: numpy.ndarray[numpy.float64], arg7: numpy.ndarray[numpy.float64], arg8: numpy.ndarray[numpy.float64], arg9: numpy.ndarray[numpy.float64], arg10: numpy.ndarray[numpy.float64], arg11: numpy.ndarray[numpy.int32], arg12: numpy.ndarray[numpy.int32], arg13: numpy.ndarray[numpy.float64], arg14: numpy.ndarray[numpy.int32]) -> HighsStatus: ...
    def passOptions(self, arg0: HighsOptions) -> HighsStatus: ...
    def passRowName(self, arg0: int, arg1: str) -> HighsStatus: ...
    @overload
    def postsolve(self, arg0: HighsSolution, arg1: HighsBasis) -> HighsStatus: ...
    @overload
    def postsolve(self, arg0: HighsSolution) -> HighsStatus: ...
    def presolve(self) -> HighsStatus: ...
    def readBasis(self, arg0: str) -> HighsStatus: ...
    def readModel(self, arg0: str) -> HighsStatus: ...
    def readOptions(self, arg0: str) -> HighsStatus: ...
    def readSolution(self, arg0: str, arg1: int) -> HighsStatus: ...
    def resetOptions(self) -> HighsStatus: ...
    def run(self) -> HighsStatus: ...
    @overload
    def setBasis(self, arg0: HighsBasis) -> HighsStatus: ...
    @overload
    def setBasis(self) -> HighsStatus: ...
    def setCallback(self, arg0: Callable[[int,str,HighsCallbackDataOut,HighsCallbackDataIn,capsule],None], arg1: capsule) -> HighsStatus: ...
    @overload
    def setOptionValue(self, arg0: str, arg1: bool) -> HighsStatus: ...
    @overload
    def setOptionValue(self, arg0: str, arg1: int) -> HighsStatus: ...
    @overload
    def setOptionValue(self, arg0: str, arg1: float) -> HighsStatus: ...
    @overload
    def setOptionValue(self, arg0: str, arg1: str) -> HighsStatus: ...
    @overload
    def setSolution(self, arg0: HighsSolution) -> HighsStatus: ...
    @overload
    def setSolution(self, arg0: int, arg1: numpy.ndarray[numpy.int32], arg2: numpy.ndarray[numpy.float64]) -> HighsStatus: ...
    def solutionStatusToString(self, arg0: int) -> str: ...
    def startCallback(self, arg0: HighsCallbackType) -> HighsStatus: ...
    def startCallbackInt(self, arg0: int) -> HighsStatus: ...
    def stopCallback(self, arg0: HighsCallbackType) -> HighsStatus: ...
    def stopCallbackInt(self, arg0: int) -> HighsStatus: ...
    def version(self) -> str: ...
    def versionMajor(self) -> int: ...
    def versionMinor(self) -> int: ...
    def versionPatch(self) -> int: ...
    def writeBasis(self, arg0: str) -> HighsStatus: ...
    def writeInfo(self, arg0: str) -> HighsStatus: ...
    def writeModel(self, arg0: str) -> HighsStatus: ...
    def writeOptions(self, arg0: str) -> HighsStatus: ...
    def writePresolvedModel(self, arg0: str) -> HighsStatus: ...
    def writeSolution(self, arg0: str, arg1: int) -> HighsStatus: ...
